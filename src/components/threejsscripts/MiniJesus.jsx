/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.12 MiniJesus.gltf --transform 
Files: MiniJesus.gltf [8.25MB] > MiniJesus-transformed.glb [499.31KB] (94%)
*/

import React, { useRef, useState, useEffect } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { useFrame, useLoader, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import { Vector3, Quaternion, MathUtils  } from 'three';
import { GLTFLoader } from 'three-stdlib'
import gsap from 'gsap';

export function MiniJesus(props) {
  const { playerRef, canvasRef, swipeDirection } = props;
  const modelRef = useRef();
  const { nodes, materials, animations } = useGLTF('/models/MiniJesus-transformed.glb')
  const { actions, names, ref, mixer } = useAnimations(animations, playerRef)
  
  //MINE
  const { animIndex, setAnimIndex } = props;
  const [keyDown, setKeyDown] = useState(false);
  const [moveDir, setMoveDir] = useState(false);
  const [moveDelta, setMoveDelta] = useState(0);
  const [camSpeed, setCamSpeed] = useState(0);
  const [hovered, setHovered] = useState(false);
  let cameraPosition;
  const [startUpCam, setStartUpCam] = useState(false);
  const [targetPosition, setTargetPosition] = useState(new Vector3(0, 0, 5));
  // const gltf = useLoader(GLTFLoader, '/models/MiniJesus-transformed.glb');
  // const mixer = new THREE.AnimationMixer();

  //DISTANCE FROM CAM
  const playerPositionNew = new THREE.Vector3();
  //ROTATION DIRECTION
  const prevRotation = useRef({ x: 0, y: 0 });
  //SPEED CAM
  const prevPosition = useRef(0);
  const startTime = useRef(0);


  useEffect(() => {
    actions['FirstPlaceWin'].setDuration(1.8);
    actions['Walk'].setDuration(1.1);
    actions['Run'].setDuration(.6);

    actions['FirstPlaceWin'].loop = THREE.LoopOnce;
    actions['Win'].loop = THREE.LoopOnce;
    console.log("ANIMATIONS", animations);

    actions['FirstPlaceWin'].clampWhenFinished = true;
    actions['Win'].clampWhenFinished = true;

    mixer.addEventListener('finished', (e) => {
      if (e.action._clip.name === "FirstPlaceWin") {
        // setIndex(3); //idle
      }
      if (e.action._clip.name === "Win") {
        setIndex(3); //idle
      }
    });

    //Control keys
    document.addEventListener('keydown', handleKeyDown, false);
    document.addEventListener('keyup', handleKeyUp, false);

    // canvasRef.current.addEventListener('mousedown', handleMouseDown);
    // canvasRef.current.addEventListener('mousemove', handleMouseMove);
    // canvasRef.current.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);

      // canvasRef.current.removeEventListener('mousedown', handleMouseDown);
      // canvasRef.current.removeEventListener('mousemove', handleMouseMove);
      // canvasRef.current.removeEventListener('mouseup', handleMouseUp);
    };
  }, [])


  const handleKeyDown = (event) => {
    if (event.shiftKey) {
      //TOGGLE
    } else {
      if (event.key.toLowerCase() === 'a') {
        setKeyDown(true);
        setMoveDir('left');
        // gsap.to(model.current.rotation, {duration: .25, repeat: 0, y: -Math.PI / 2});
      }
      if (event.key.toLowerCase() === 'd') {
        setKeyDown(true);
        setMoveDir('right');
        // gsap.to(model.current.rotation, {duration: .25, repeat: 0, y: Math.PI / 2});
      }
      console.log(event.key.toLowerCase());
    }
  }

  const handleKeyUp = (event) => {
    if (event.key.toLowerCase() === 'a' || event.key.toLowerCase() === 'd') {
      setKeyDown(false);
    }
  }


  useEffect(() => {
    if (keyDown) setAnimIndex(5); //RUN
    if (!keyDown) setAnimIndex(3); //IDLE
  }, [keyDown])

  
  useEffect(() => {
    console.log('ACTIONS', actions);
    actions[names[animIndex]].reset().fadeIn(0.5).play();
    return () => actions[names[animIndex]].fadeOut(0.5);
  }, [animIndex, actions, names])


  // MOUSE INPUT

  // const handleMouseDown = (event) => {
  //   dragging = true;
  //   setInitialMouseY(event.clientY);
  //   setInitialCameraY(cameraPosition.y);
  //   console.log("DOEN");
  // };
  
  // const handleMouseMove = (event) => {
  //   if (dragging) 
  //   {
  //     const deltaY = event.clientY - initialMouseY;
  //     console.log(deltaY);
  //     const newCameraY = initialCameraY - deltaY * 0.01; // Adjust the factor for sensitivity
  //     setCameraYPos(newCameraY);
  //   }
  // };
  
  // const handleMouseUp = () => {
  //   console.log("UP");
  //   dragging = false;
  // };

  const [speedDifference, setSpeedDifference] = useState(10);
  const [idleStance, setIdleStance] = useState(true);
  const previousPositionRef = useRef(new THREE.Vector3())

  useEffect(() => {
    if (idleStance) setAnimIndex(3);
    if (!idleStance) setAnimIndex(5);
  }, [idleStance])

  const camSpeedFunc = (speed) => {
    
    setSpeedDifference(20 - speed);
    
    if (speedDifference < 0.2) setSpeedDifference(0.2);
    
    actions['Run'].setDuration(speedDifference);
    
    if (speedDifference < 5) {
      setIdleStance(false);
    }
    else if (speedDifference > 18) {
      setIdleStance(true);
    }
  }
  

  useFrame((state, delta ) => {
    const radius = 32; // Adjust the radius of the circle
    let angle;
    

    // KEY DOWN METHOD
    // if (keyDown) {
    //   if (moveDir === 'left') {
    //     setMoveDelta(moveDelta + delta);
    //     faceMovementDir(2.5, state.camera, angle, radius);
    //   }
    //   if (moveDir === 'right') {
    //     setMoveDelta(moveDelta - delta);
    //     faceMovementDir(-2.5, state.camera, angle, radius);
    //   };
    // }

    
    // NEW ROTATION METHOD
    // const currentRotation = state.camera.rotation.clone();
    // // Compare current rotation with previous rotation to detect left or right rotation
    // const rotationDelta = {
    //   x: currentRotation.x - prevRotation.current.x,
    //   y: currentRotation.y - prevRotation.current.y,
    // };
    // // Detect rotation direction based on rotationDelta values
    // if (rotationDelta.y > 0) {
    //   setMoveDir('left');
    // } else if (rotationDelta.y < 0) {
    //   setMoveDir('right');
    // }
    // // Update the previous rotation
    // prevRotation.current = currentRotation.clone();
    

    //SPEED CAPTURE
    const currentTime = state.clock.getElapsedTime();
    const currentPosition = state.camera.position.clone();
     // Calculate distance moved since last frame
    const distanceMoved = currentPosition.distanceTo(prevPosition.current);
    // Calculate time difference since last frame
    const deltaTime = currentTime - startTime.current;
    // Calculate speed based on distance and time
    const speed = distanceMoved / deltaTime;
    camSpeedFunc(speed);
    // console.log('Camera speed:', speed);
    // Update previous position and start time
    prevPosition.current = currentPosition;
    startTime.current = currentTime;



    // WORKS 1 !! 
    const playerPosition2 = playerRef.current.position.clone();
      const previousPosition2 = previousPositionRef.current.clone();
      // Calculate the movement vector
      const movementVector = playerPosition2.clone().sub(previousPosition2);
      // Calculate the direction by normalizing the movement vector
      const direction = movementVector.clone().normalize();
      // Rotate the direction vector 90 degrees to the left
      const leftDirection = new THREE.Vector3(-direction.z, direction.y, direction.x).normalize();
      // Update the previous position for the next frame
      previousPositionRef.current.copy(playerPosition2);
      console.log('Left Movement Direction:', leftDirection.x, leftDirection.y, leftDirection.z);
      playerRef.current.lookAt(leftDirection.x, leftDirection.y, leftDirection.z);

      modelRef.current.rotation.y = Math.PI / 2;
      // modelRef.current.lookAt(0,0,0);

    // WORKS 2 !!
    // const previousPosition2 = previousPositionRef.current.clone();
    // const playerPosition2 = playerRef.current.position.clone();
    // const movementVector = playerPosition2.clone().sub(previousPosition2);
    // const direction = movementVector.clone().normalize();
    // // Calculate the left direction by rotating the direction 90 degrees around the up axis
    // const leftDirection = new THREE.Vector3(direction.z, direction.y, -direction.x).normalize();
    // // Make the player face the left direction
    // playerRef.current.lookAt(playerPosition2.clone().add(leftDirection));
    // // Update the previous position for the next frame
    // previousPosition2.copy(playerPosition2);





    cameraPosition = state.camera.position;
    const playerPosition = playerRef.current.position;
    //MISC
    // angle = moveDelta * 1.00;
    // const angle = Date.now() * 0.001 * 1;

    // Update the player's position
    // const x = Math.cos(angle) * radius;
    // const z = Math.sin(angle) * radius;
    // playerRef.current.position.x = x;
    // playerRef.current.position.z = z;

    //LERPING
    // Calculate the direction from the model to the target
    const lookAtDirection = new Vector3().subVectors(targetPosition, playerRef.current.position).normalize();
    // Calculate the quaternion rotation to look at the target
    const targetQuaternion = new Quaternion().setFromUnitVectors(new Vector3(0, 0, 1), lookAtDirection);
    // Interpolate the current rotation towards the target rotation
    const lerpFactor = 0.1; // Adjust the lerp factor for desired smoothness
    playerRef.current.quaternion.slerp(targetQuaternion, lerpFactor);


    // 2 - Cam Spinner
    // const cameraX = playerPosition.x + Math.cos(angle) * radius / 2.2;
    // const cameraZ = playerPosition.z + Math.sin(angle) * radius / 2.2;
    // state.camera.position.set(cameraX, 1.75, cameraZ);
    // state.camera.position.x = cameraX;
    // state.camera.position.z = cameraZ;

    state.camera.lookAt(0, 0, 0);

    if (!startUpCam) 
    {
      // state.camera.position.set(cameraX, 1.75, cameraZ);
      prevPosition.current = state.camera.position.clone();
      
      const x = Math.cos(0) * radius;
      const z = Math.sin(0) * radius;
      playerRef.current.position.x = x;
      playerRef.current.position.z = z;

      const cameraX = playerRef.current.position.x + Math.cos(0) * radius / 2.2;
      const cameraZ = playerRef.current.position.z + Math.sin(0) * radius / 2.2;
      state.camera.position.x = cameraX;
      state.camera.position.z = cameraZ;

      setStartUpCam(true);
      setTargetPosition(new Vector3(state.camera.position.x, 0, state.camera.position.z));
    }

    const distance = 14.5; // Distance from the camera
    playerPositionNew.copy(state.camera.position);
    state.camera.getWorldDirection(playerPositionNew);
    playerPositionNew.multiplyScalar(distance).add(state.camera.position);
    playerPositionNew.y = 0;
    playerRef.current.position.copy(playerPositionNew);
  })

  const faceMovementDirScroll = (offsetDistance) => {
    // Calculate the rotation angle based on player's rotation
    const playerRotation = Math.atan2(playerRef.current.position.z, playerRef.current.position.x);

    // Calculate the offset direction by adding 90 degrees (pi/2 radians) to the player's rotation
    const offsetDirection = playerRotation + Math.PI / 2;

    // Calculate the offset position based on the offset direction and distance
    const offsetX = playerRef.current.position.x + Math.cos(offsetDirection) * offsetDistance;
    const offsetZ = playerRef.current.position.z + Math.sin(offsetDirection) * offsetDistance;
    setTargetPosition(new Vector3(offsetX, 0, offsetZ));
  }

  const faceMovementDir = (offsetDistance, camera, angle, radius) => {
    // const cameraX2 = playerRef.current.position.x + Math.cos(angle) * radius;
    // const cameraZ2 = playerRef.current.position.z + Math.sin(angle) * radius;
    // // camera.position.set(cameraX2, 1.75, cameraZ2);
    // camera.position.x = cameraX2;
    // camera.position.z = cameraZ2;

    // Calculate the rotation angle based on player's rotation
    const playerRotation = Math.atan2(playerRef.current.position.z, playerRef.current.position.x);

    // Calculate the offset direction by adding 90 degrees (pi/2 radians) to the player's rotation
    const offsetDirection = playerRotation + Math.PI / 2;

    // Calculate the offset position based on the offset direction and distance
    const offsetX = playerRef.current.position.x + Math.cos(offsetDirection) * offsetDistance;
    const offsetZ = playerRef.current.position.z + Math.sin(offsetDirection) * offsetDistance;
    setTargetPosition(new Vector3(offsetX, 0, offsetZ));
  }
  


  const clickedJesus = () => {
    if (keyDown) return;
    setAnimIndex(7); //2 alt
    setTargetPosition(new Vector3(cameraPosition.x, 0, cameraPosition.z));
    // gsap.to(modelRef.current, {duration: .5, repeat: 0, lookAt: (cameraPosition.x, 0, cameraPosition.z)});
    // model.current.lookAt(cameraPos.x, 0, cameraPos.z);
  }

  return (
    <group ref={playerRef} {...props} dispose={null} position={[0,0,0]}>
      <group ref={modelRef} name="Scene">
        <group name="MiniJesus" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <primitive object={nodes.Hip_J} />
        </group>
        <group castShadow name="Mini_Jesus" rotation={[Math.PI / 2, 0, 0]} scale={0.01}
           onPointerOver={() => setHovered(true)} 
           onPointerOut={() => setHovered(false)} 
           onClick={() => clickedJesus()}
          >
          <skinnedMesh name="Mesh" geometry={nodes.Mesh.geometry} material={materials.PaletteMaterial001} skeleton={nodes.Mesh.skeleton} />
          <skinnedMesh name="Mesh_1" geometry={nodes.Mesh_1.geometry} material={materials.PaletteMaterial001} skeleton={nodes.Mesh_1.skeleton} />
          <skinnedMesh name="Mesh_2" geometry={nodes.Mesh_2.geometry} material={materials.PaletteMaterial001} skeleton={nodes.Mesh_2.skeleton} />
          <skinnedMesh name="Mesh_3" geometry={nodes.Mesh_3.geometry} material={materials.PaletteMaterial001} skeleton={nodes.Mesh_3.skeleton} />
          <skinnedMesh name="Mesh_4" geometry={nodes.Mesh_4.geometry} material={materials.PaletteMaterial001} skeleton={nodes.Mesh_4.skeleton} />
          <skinnedMesh name="Mesh_5" geometry={nodes.Mesh_5.geometry} material={materials.PaletteMaterial001} skeleton={nodes.Mesh_5.skeleton} />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/MiniJesus-transformed.glb')
