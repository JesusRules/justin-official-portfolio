/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.12 MiniJesus.gltf --transform 
Files: MiniJesus.gltf [8.25MB] > MiniJesus-transformed.glb [499.31KB] (94%)
*/

import React, { useRef, useState, useEffect } from 'react'
import { useGLTF, useAnimations, useFBX } from '@react-three/drei'
import { act, useFrame, useLoader, useThree } from '@react-three/fiber';
import * as THREE from 'three';
import { Vector3, Quaternion, MathUtils  } from 'three';
import { GLTFLoader } from 'three-stdlib'
import gsap from 'gsap';
import { FBXLoader } from "three/examples/jsm/loaders/FBXLoader";

export function MiniJesusFBX(props) {
  const { playerRef, canvasRef, speechBubbleRef, touchObjects, setCurrentProject, setWithinProject,
          idleStance, setIdleStance, cameraPosition, setCameraPosition, setIsLoaded,
          startUpCam, setStartUpCam } = props;

  const modelRef = useRef();

  const { nodes, materials, animations } = useFBX('/models/MiniJesus.fbx'); //old
  const { actions, names, ref, mixer } = useAnimations(animations, playerRef)
  const fbxRef = useRef();
  let fbx = useFBX('/models/MiniJesus.fbx')
  // const { animations } = useFBX('/models/MiniJesus.fbx', (fbx) => {
  //   fbxRef.current = fbx;
  // });
  // const { actions, mixer } = useAnimations(animations, fbxRef);
  // const fbx = useLoader(FBXLoader, "/models/MiniJesus.fbx");

  const playAnimation = (animationName) => {
    actions[animationName].play();
  };

  //MINE
  const { animIndex, setAnimIndex } = props;
  const radius = 98; // Adjust the radius of the circle

  const [moveDir, setMoveDir] = useState(false);
  const [hovered, setHovered] = useState(false);
  const [swipeDirection, setSwipeDirection] = useState(0);
  const [isMoving, setIsMoving] = useState(false);
  let startX;
  // let cameraPosition;
  // const [startUpCam, setStartUpCam] = useState(false);
  const [targetRotation, setTargetRotation] = useState(-Math.PI);
  const [speedDifference, setSpeedDifference] = useState(10);
  // const [idleStance, setIdleStance] = useState(true); //outside! (Projects)
  // const gltf = useLoader(GLTFLoader, '/models/MiniJesus-transformed.glb');
  // const mixer = new THREE.AnimationMixer();
  
  const prevCameraPosition = useRef([0, 1.75, 5]);
  const [isTouchingAnySphere, setIsTouchingAnySphere] = useState(true);
  //DISTANCE FROM CAM
  const playerPositionNew = new THREE.Vector3();
  //SPEED CAM
  const prevPosition = useRef(0);
  const startTime = useRef(0);

  useEffect(() => {
    actions['Armature|FirstPlaceWin'].setDuration(1.8);
    actions['Armature|Walk'].setDuration(1.1);
    actions['Armature|Run'].setDuration(.6);

    actions['Armature|FirstPlaceWin'].loop = THREE.LoopOnce;
    actions['Armature|Win'].loop = THREE.LoopOnce;
    // console.log("ANIMATIONS", animations);

    actions['Armature|FirstPlaceWin'].clampWhenFinished = true;
    actions['Armature|Win'].clampWhenFinished = true;

    mixer.addEventListener('finished', (e) => {
      if (e.action._clip.name === "Armature|FirstPlaceWin") {
        // setIndex(3); //idle
      }
      if (e.action._clip.name === "Armature|Win") {
        setAnimIndex(2); //idle
      }
      if (e.action._clip.name === "Armature|Run") {
        // setTargetRotation(-Math.PI);
      }
    });
    setIsLoaded(true); 

    canvasRef.current.addEventListener("touchstart", handleTouchStart);
    canvasRef.current.addEventListener("touchmove", handleTouchMove);
    canvasRef.current.addEventListener("touchend", handleTouchEnd);

    canvasRef.current.addEventListener('mousedown', handleMouseDown);
    canvasRef.current.addEventListener('mousemove', handleMouseMove);
    canvasRef.current.addEventListener('mouseup', handleMouseUp);

    return () => {
      // document.removeEventListener('keydown', handleKeyDown);
      // document.removeEventListener('keyup', handleKeyUp);
      if (canvasRef.current)
      {
        canvasRef.current.removeEventListener("touchstart", handleTouchStart);
        canvasRef.current.removeEventListener("touchmove", handleTouchMove);
        canvasRef.current.removeEventListener("touchend", handleTouchEnd);
  
        canvasRef.current.removeEventListener('mousedown', handleMouseDown);
        canvasRef.current.removeEventListener('mousemove', handleMouseMove);
        canvasRef.current.removeEventListener('mouseup', handleMouseUp);
      }
    };
  }, [])


  // TOUCH /////////////////
  const handleTouchStart = (event) => {
    startX = event.touches[0].clientX;
  };
  
  const handleTouchMove = (event) => {
    if (startX !== null) {
      const currentX = event.touches[0].clientX;
      const deltaX = currentX - startX;
      setIsMoving(true);
      if (deltaX > 0) {
        setMoveDir('left');
        setTargetRotation(-4.71239);
      } else if (deltaX < 0) {
        setMoveDir('right');
        setTargetRotation(-1.5708);
      }
      startX = currentX;
    }
  };

  const handleTouchEnd = () => {
    startX = null;
    setIsMoving(false);
    setSwipeDirection(null);
  };
  


  // MOUSE ///////////////
  const handleMouseDown = (event) => {
    startX = event.clientX;
  };
  
  const handleMouseMove = (event) => {
    if (startX !== null) {
      const currentX = event.clientX;
      const deltaX = currentX - startX;
      setIsMoving(true);
      if (deltaX > 0) {
        setMoveDir('left');
        setTargetRotation(-4.71239);
      } else if (deltaX < 0) {
        setMoveDir('right');
        setTargetRotation(-1.5708);
      }
      startX = currentX;
    }
  };
  
  const handleMouseUp = () => {
    startX = null;
    setIsMoving(false);
    setSwipeDirection(null);
  };

  useEffect(() => {
    if (isMoving) {
      setAnimIndex(3);
    } else {
      setAnimIndex(2);
    }
  }, [isMoving])

  // BOTH TOUCH AND MOUSE
  const HideBubble = () => {
    //Hide bubble
    gsap.to(speechBubbleRef.current, {
      duration:0.5,
      opacity: 0,
      transform: 'translateY(-30px)',
    }); 
  }

  // const handleKeyDown = (event) => {
  //   if (event.shiftKey) {
  //     //TOGGLE
  //   } else {
  //     if (event.key.toLowerCase() === 'a') {
  //       setKeyDown(true);
  //       setMoveDir('left');
  //     }
  //     if (event.key.toLowerCase() === 'd') {
  //       setKeyDown(true);
  //       setMoveDir('right');
  //     }
  //     console.log(event.key.toLowerCase());
  //   }
  // }

  // const handleKeyUp = (event) => {
  //   if (event.key.toLowerCase() === 'a' || event.key.toLowerCase() === 'd') {
  //     setKeyDown(false);
  //   }
  // }

  // useEffect(() => {
  //   if (keyDown) setAnimIndex(5); //RUN
  //   if (!keyDown) setAnimIndex(3); //IDLE
  // }, [keyDown])

  
  useEffect(() => {
    if (actions[names[animIndex]]) {
      actions[names[animIndex]].reset().fadeIn(0.5).play();
    }
    return () => {
      if (actions[names[animIndex]]) {
        actions[names[animIndex]].fadeOut(0.5);
      }
    };
  }, [animIndex, actions, names])


  // useEffect(() => {
  //   if (idleStance) setAnimIndex(3); //idle
  //   if (!idleStance) {
  //     setAnimIndex(5); //run 
  //   }
  // }, [idleStance])


  const camSpeedFunc = (speed) => {
    setSpeedDifference(20 - speed);
    
    if (speedDifference < 0.2) setSpeedDifference(0.2);
    // actions['Run'].setDuration(speedDifference);
    
    if (speedDifference < 3.3) { //5
    }
    if (speedDifference > 16) { //14
      setIsMoving(false);
      if (moveDir === 'left') setTargetRotation(-3.14159);
      if (moveDir === 'right') setTargetRotation(-3.14159);
    }
  }

  useFrame((state, delta ) => {
    let angle;

    const distance = 25.2; // Distance from the camera // 25.2
    playerPositionNew.copy(state.camera.position);
    state.camera.getWorldDirection(playerPositionNew);
    playerPositionNew.multiplyScalar(distance).add(state.camera.position);
    playerPositionNew.y = 0;
    playerRef.current.position.copy(playerPositionNew);
    // KEY DOWN METHOD
    // if (keyDown) {
    //   if (moveDir === 'left') {
    //     setMoveDelta(moveDelta + delta);
    //     faceMovementDir(2.5, state.camera, angle, radius);
    //   }
    //   if (moveDir === 'right') {
    //     setMoveDelta(moveDelta - delta);
    //     faceMovementDir(-2.5, state.camera, angle, radius);
    //   };
    // }
    
    //SPEED CAPTURE
    const currentTime = state.clock.getElapsedTime();
    const currentPosition = state.camera.position.clone();
    const distanceMoved = currentPosition.distanceTo(prevPosition.current);
    const deltaTime = currentTime - startTime.current;
    const speed = distanceMoved / deltaTime;
    camSpeedFunc(speed);
    //update
    prevPosition.current = currentPosition;
    startTime.current = currentTime;



    const lerpFactor = 0.10; //0.05
    playerRef.current.lookAt(0, 0, 0); //stays
    const currentRotation = modelRef.current.rotation.y;
    const lerpedRotation = THREE.MathUtils.lerp(currentRotation, targetRotation, lerpFactor);
    modelRef.current.rotation.y = lerpedRotation;
      
    // -Math.PI = FRONT
      // Math.PI / 2 = LEFT
      // -Math.PI / 2 = RIGHT
      // 0 = BACK

    // cameraPosition = state.camera.position;
    
    //MISC
    // angle = moveDelta * 1.00;
    // const angle = Date.now() * 0.001 * 1;

    // Update the player's position
    // const x = Math.cos(angle) * radius;
    // const z = Math.sin(angle) * radius;
    // playerRef.current.position.x = x;
    // playerRef.current.position.z = z;

    // 2 - Cam Spinner
    // const cameraX = playerPosition.x + Math.cos(angle) * radius / 2.2;
    // const cameraZ = playerPosition.z + Math.sin(angle) * radius / 2.2;
    // state.camera.position.set(cameraX, 1.75, cameraZ);
    // state.camera.position.x = cameraX;
    // state.camera.position.z = cameraZ;

    state.camera.lookAt(0, 0, 0);

    let isTouchingAnySphere2 = false;

    // Touch sphere interaction
    touchObjects.forEach(sphere => {
      const distance = playerRef.current.position.distanceTo(new Vector3(sphere.props.position[0], sphere.props.position[1], sphere.props.position[2])); //sphere.position, sphere.content
      // const distance = playerPosition.distanceTo(sphere); //sphere.position, sphere.content
      if (distance < 3) { //4
        setCurrentProject(sphere.props.content);
        if (sphere.props.content.name !== "") setWithinProject(true);
        isTouchingAnySphere2 = true;
      }
    })

    if (!isTouchingAnySphere2) {
      // setCurrentProject("");
      setWithinProject(false);
    }
    

    if (!startUpCam) 
    {
      prevPosition.current = state.camera.position.clone();
      
      const x = Math.cos(0) * radius;
      const z = Math.sin(0) * radius;
      if (cameraPosition[1] === 2) 
      {
        playerRef.current.position.x = x;
        playerRef.current.position.z = z;
        const cameraX = playerRef.current.position.x + Math.cos(0) * radius; //2.2
        const cameraZ = playerRef.current.position.z + Math.sin(0) * radius; //2.2      
        state.camera.position.x = cameraX;
        state.camera.position.z = cameraZ;
      } 
      else 
      {
        state.camera.position.x = cameraPosition[0] * 1.0000; //1.0007
        state.camera.position.z = cameraPosition[2] * 1.0000; //1.0007
      }

      setStartUpCam(true);
    }

    const currentPositionCamera = state.camera.position.toArray();
    if (
        Math.round(currentPositionCamera[0]) !== Math.round(prevCameraPosition.current[0]) ||
        Math.round(currentPositionCamera[1]) !== Math.round(prevCameraPosition.current[1]) ||
        Math.round(currentPositionCamera[2]) !== Math.round(prevCameraPosition.current[2])
    ) {
      prevCameraPosition.current = currentPositionCamera;
      HideBubble();
      setCameraPosition([state.camera.position.x, 1.75, state.camera.position.z])
    }
  })


  const clickedJesus = () => {
    console.log(actions);
    setAnimIndex(1); //Armature|Win
    if (moveDir === 'left') setTargetRotation(-3.14159);
      if (moveDir === 'right') setTargetRotation(-3.14159);
  }

  const ribbonMat = new THREE.MeshStandardMaterial({
    color: '#49c7ff', // Set your desired color here (hex value).
  });
  const skinMat = new THREE.MeshStandardMaterial({
    color: '#ff8e56', // Set your desired color here (hex value).
  });
  const hairMat = new THREE.MeshStandardMaterial({
    color: '#351805', // Set your desired color here (hex value).
  });

  return (
    <group onClick={clickedJesus} ref={playerRef} {...props} dispose={null} position={[0,0,0]}>
      <primitive ref={modelRef} object={fbx} scale={0.01} rotation={[0, -Math.PI, 0]} />
    </group>
  )
}

// useGLTF.preload('/models/MiniJesus-transformed.glb')

// 0 = Armature|Clapping
// 1 = Armature|Win
// 2 = Armature|Idle
// 3 = Armature|Run
// 4 = Armature|FirstPlaceWin
// 5 = Armature|Walk